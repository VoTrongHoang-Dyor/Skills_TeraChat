Pattern_ID,Category,Pattern_Name,Description_VI,Anti_Pattern,Good_Example,Crate_Dependency,Spec_Ref
CP001,Key_Material,Zeroize_on_Drop,Mọi struct chứa key material phải auto-zero khi Drop để chống RAM dump,Dùng Vec<u8> hoặc String thông thường cho key,"#[derive(zeroize::Zeroize, zeroize::ZeroizeOnDrop)] struct SessionKey { inner: [u8; 32] }",zeroize,Section 2.3
CP002,Key_Material,Secret_Wrapper,Bọc sensitive data trong secrecy::Secret để ngăn log/debug accidental leak,Để raw key trong struct field thông thường,"let key: secrecy::Secret<Vec<u8>> = Secret::new(raw_bytes);",secrecy,Section 2.3
CP003,Memory,RAM_Lock,Ghim trang nhớ chứa key để OS không swap ra disk,Bỏ qua mlock — OS tự do swap key ra SSD,"unsafe { libc::mlock(ptr, size); } // Linux/macOS | VirtualLock on Windows",libc,Section 2.3
CP004,FFI,Catch_Unwind_FFI,Bọc tất cả pub extern C fn trong catch_unwind để chặn Rust panic vượt FFI boundary,Để unwind thoát qua FFI → crash Swift/C caller,"std::panic::catch_unwind(|| { /* logic */ }).unwrap_or_else(|_| FfiResult::error(500, ""ERR_CORE_POISONED""))","std::panic",Section 2.7
CP005,FFI,No_Raw_Pointer_Trust,Không tin tưởng len từ C caller — luôn bounds check trước slice::from_raw_parts,Dùng len trực tiếp từ C không validate,"if len > MAX_BUF { return FfiResult::error(400, ""ERR_INVALID_LEN""); } let slice = unsafe { std::slice::from_raw_parts(ptr, len) };","std::slice",Section 2.8
CP006,Crypto,AEAD_Seal,Dùng AEAD (ChaCha20-Poly1305 / AES-256-GCM) cho tất cả encrypt — KHÔNG DÙNG AES-CBC,Dùng AES-CBC hoặc ECB mode,"use ring::aead::{Aad, LessSafeKey, Nonce, CHACHA20_POLY1305}; let key = LessSafeKey::new(UnboundKey::new(&CHACHA20_POLY1305, key_bytes)?);",ring,Section 2.1
CP007,Crypto,Ed25519_Signing,Dùng Ed25519 cho signature (không dùng RSA hay ECDSA với weak params),ECDSA với secp256k1 không có proper nonce,"use ed25519_dalek::{Keypair, Signer}; let sig = keypair.sign(message_bytes);",ed25519-dalek,Section 2.4
CP008,Crypto,X25519_Key_Exchange,Dùng X25519 cho Ephemeral Key Exchange — tạo new keypair mỗi session,Tái sử dụng static keypair cho mọi session — mất Perfect Forward Secrecy,"use x25519_dalek::{EphemeralSecret, PublicKey}; let secret = EphemeralSecret::random_from_rng(OsRng);",x25519-dalek,Section 2.1
CP009,Serialization,Protobuf_Not_JSON,Dùng Protobuf (prost) cho FFI/Network — type-safe và compact hơn JSON,Dùng serde_json cho FFI payload — bloat và không type-safe,"use prost::Message; let bytes = MyMessage { field: 42 }.encode_to_vec();",prost,Section 2.1
CP010,Logging,No_PII_Log,Tuyệt đối không log payload content — chỉ log correlation_id và error code,tracing::info!(""Message content: {}"" message_content),"tracing::info!(correlation_id = %req_id, ""Request processed""); tracing::error!(code = ""E_AUTH_FAIL"", ""Auth failed"");",tracing,Section 2.7
CP011,Concurrency,RwLock_Poison_Policy,Khi RwLock bị poisoned → trả về ERR và wipe state — không dùng clear_poison,Gọi .lock().unwrap_or_else(|e| e.into_inner()) — giữ poisoned state,"let guard = lock.read().map_err(|_| TcError::PoisonedState)?;","std::sync::RwLock",Section 2.3
CP012,String,Obfstr_Literals,Mã hóa XOR compile-time cho string nhạy cảm trong binary,Để plain string literal trong binary — dễ extract bằng strings command,"use obfstr::obfstr; let endpoint = obfstr!(""internal-cluster.terachat"");",obfstr,Section 2.7
